using BepInEx;
using BepInEx.Configuration;
using BepInEx.Logging;
using HarmonyLib;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace PowerSystemTweek
{
    [BepInPlugin(GUID, NAME, VERSION)]
    [BepInProcess(GAME_PROCESS)]
    public class PowerSystemTweakPlugin : BaseUnityPlugin
    {
        public const string GUID = "cn.chewei.dsp.power_system_tweak";
        public const string NAME = "PowerSystemTweek";
        public const string VERSION = "1.0.0";
        public const string GAME_PROCESS = "DSPGAME.exe";
        static ManualLogSource BepInLogger;
        private ConfigEntry<bool> configPreferCleanEnergyGenerator;
        private ConfigEntry<int> configExcDischargeEqualFuelGenerator;
        private double nextLogTime = Time.time;
        private bool showDebugUI = false;
        private StringBuilder debugLog = new StringBuilder(2048);
        public List<int> ListExecutionTimeIndex = new List<int>(512);
        public List<double> ListExecutionTime = new List<double>(512);
        public double ExecTimeMin;
        public double ExecTimeMax;
        public double ExecTimeMedian;
        public double ExecTimeAverage;

        public void Start()
        {
            BepInLogger = Logger;
            Config.SaveOnConfigSet = true;
            configPreferCleanEnergyGenerator = Config.Bind("General", "PreferCleanEnergyGenerator", true, "Whether enables the patch to use energy from clean energy generators before using energy generated by fuel");
            configExcDischargeEqualFuelGenerator = Config.Bind("General", "ExcDischargeEqualFuelGenerator", 0, "0:Exchangers discharge as fuel generators, 1: Echangers will discharge first to save fuel, 2: Echangers will discharge last as backup energy");
            PowerSystemPatch.PowerSystemGameTickPatch = configPreferCleanEnergyGenerator.Value;
            if (configExcDischargeEqualFuelGenerator.Value > 0 && configExcDischargeEqualFuelGenerator.Value < 3)
            PowerSystemPatch.ExchangerDischargeStrategy = (EExchangerDischargeStrategy)(configExcDischargeEqualFuelGenerator.Value);
            if (!CheckMethodPatchInfo(typeof(PowerSystem), "GameTick"))
            {
                PowerSystemPatch.InitStopWatch();
                Harmony.CreateAndPatchAll(typeof(PowerSystemPatch));
            }
            else
            {
                BepInLogger.LogInfo("Give up Patch to avoid conflict");
            }
        }
        public void Update()
        {
            if (Input.GetKey(KeyCode.LeftControl))
            {
                if (Input.GetKeyUp(KeyCode.Y))
                {
                    PowerSystemPatch.PowerSystemGameTickPatch = !PowerSystemPatch.PowerSystemGameTickPatch;
                    configPreferCleanEnergyGenerator.Value = PowerSystemPatch.PowerSystemGameTickPatch;
                    UIRealtimeTip.Popup(PowerSystemPatch.PowerSystemGameTickPatch ? "PowerSystemTweak Enabled" : "PowerSystemTweak Disabled");
                }

                if (Input.GetKeyUp(KeyCode.U))
                {
                    showDebugUI = !showDebugUI;
                }
            }

            if (showDebugUI)
            {
                UpdateExecTimeStat();
            }
        }

        public void OnGUI()
        {
            if (showDebugUI)
            {
                GUILayout.BeginArea(new Rect(Screen.width * 0.7f, 0, Screen.width * 0.3f, Screen.height));
                GUILayout.Label(debugLog.ToString(), new GUIStyle(GUI.skin.label) { fontSize = 24});
                GUILayout.EndArea();
            }
        }
        private void UpdateExecTimeStat()
        {
            if (GameMain.isRunning && Time.time > nextLogTime && !DSPGame.IsMenuDemo)
            {
                nextLogTime = Time.time + 1.0;
                ListExecutionTimeIndex.Clear();
                ListExecutionTime.Clear();

                for (int factoryIndex = 0; factoryIndex < GameMain.data.factoryCount; factoryIndex++)
                {
                    if (GameMain.data.factories[factoryIndex] != null)
                    {
                        ListExecutionTimeIndex.Add(factoryIndex);
                        ListExecutionTime.Add(PowerSystemPatch.ExecuteTime[factoryIndex]);
                    }
                }
                ListExecutionTimeIndex.Sort((a, b) => { return Math.Sign(PowerSystemPatch.ExecuteTime[b] - PowerSystemPatch.ExecuteTime[a]); });
                ListExecutionTime.Sort();

                debugLog.Clear();

                if (GameMain.localPlanet != null)
                {
                    int localFactoryIndex = GameMain.localPlanet.factoryIndex;
                    var planetName = GameMain.data.factories[localFactoryIndex].planet.displayName;
                    var factory = GameMain.data.factories[localFactoryIndex];
                    debugLog.AppendFormat("Local System:{0} {1} Time:{2:N3}ms Weight{3}",
                                        localFactoryIndex,
                                        planetName,
                                        1000.0 * PowerSystemPatch.ExecuteTime[localFactoryIndex],
                                        factory.powerSystem.GetPowerSystemWeight()).AppendLine();
                }

                for (int i = 0; i < 10 && i < GameMain.data.factoryCount; i++)
                {
                    var planetName = GameMain.data.factories[ListExecutionTimeIndex[i]].planet.displayName;
                    var factory = GameMain.data.factories[ListExecutionTimeIndex[i]];
                   
                    debugLog.AppendFormat("Factory Index:{0} {1} Time:{2:N3}ms Weight{3}",
                                        ListExecutionTimeIndex[i],
                                        planetName,
                                        1000.0 * PowerSystemPatch.ExecuteTime[ListExecutionTimeIndex[i]],
                                        factory.powerSystem.GetPowerSystemWeight()).AppendLine();
                }

                debugLog.AppendFormat("Min {0:N3}ms, Max{1:N3}ms, Avg{2:N3}ms, Median{3:N3}ms",
                                                  ListExecutionTime.Min() * 1000.0,
                                                  ListExecutionTime.Max() * 1000.0,
                                                  ListExecutionTime.Average() * 1000.0,
                                                  ListExecutionTime[ListExecutionTime.Count / 2] * 1000.0).AppendLine();
            }
        }
        static bool CheckMethodPatchInfo(Type typeClass, string MethodName)
        {
            // get the MethodBase of the original
            var original = typeClass.GetMethod(MethodName);

            // retrieve all patches
            var patches = Harmony.GetPatchInfo(original);
            if (patches is null) return false; // not patched

            // get a summary of all different Harmony ids involved
            BepInLogger.LogInfo("all owners: " + patches.Owners);

            // get info about all Prefixes/Postfixes/Transpilers
            foreach (var patch in patches.Prefixes)
            {
                BepInLogger.LogInfo("index: " + patch.index);
                BepInLogger.LogInfo("owner: " + patch.owner);
                BepInLogger.LogInfo("patch method: " + patch.PatchMethod);
                BepInLogger.LogInfo("priority: " + patch.priority);
                BepInLogger.LogInfo("before: " + patch.before);
                BepInLogger.LogInfo("after: " + patch.after);
            }
            return true;
        }
    }
}